{
  "version": 3,
  "sources": ["../src/scopie.js"],
  "sourcesContent": ["export const arraySeperator = '|';\nexport const blockSeperator = '/';\nexport const wildcard = '*';\nexport const varPrefix = '@';\n\nexport const allowPermission = \"allow\";\nexport const denyPermission = \"deny\";\n\n/** Checks character validity\n * @param {character} char - Single character to check\n * @returns {boolean} whether or not the character is valid within a scope.\n */\nfunction isValidCharacter(char) {\n  if (char >= 'a' && char <= 'z') {\n    return true;\n  }\n\n  if (char >= 'A' && char <= 'Z') {\n    return true;\n  }\n\n  if (char >= '0' && char <= '9') {\n    return true;\n  }\n\n  return char === '_' || char === '-' || char === varPrefix || char === wildcard;\n}\n\n/** Calculates the end of an array element\n * @param {string} value - Value of our scope we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the array element\n */\nfunction endOfArrayElement(value, start) {\n  for (let i = start + 1; i < value.length; i += 1) {\n    if (value[i] === blockSeperator || value[i] === arraySeperator) {\n      return i;\n    }\n  }\n\n  return value.length;\n}\n\n/** Calculates the end of a scope block\n * @param {string} category - Value to use when returning an error for our category\n * @param {string} value - Value of our scope we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the scope block\n */\nfunction endOfBlock(category, value, start) {\n  for (let i = start; i < value.length; i += 1) {\n    if (value[i] === blockSeperator) {\n      return i;\n    } if (value[i] === arraySeperator) {\n      continue;\n    } else if (!isValidCharacter(value[i])) {\n      throw new Error(`scopie-100 in ${category}: invalid character '${value[i]}'`);\n    }\n  }\n\n  return value.length;\n}\n\n/** Compares two strings with respect to variables and wildcards.\n * @param {string} rule\n * @param {int} ruleLeft\n * @param {int} ruleSlider\n * @param {string} scope\n * @param {int} scopeLeft\n * @param {int} scopeSlider\n * @param {Map<string,string>} vars\n * @returns {boolean} Whether or not our rule block matches the scope block\n */\nfunction compareBlock(rule, ruleLeft, ruleSlider, scope, scopeLeft, scopeSlider, vars) {\n  if (rule[ruleLeft] === varPrefix) {\n    const key = rule.substring(ruleLeft + 1, ruleSlider);\n    if (!vars.has(key)) {\n      throw new Error(`scopie-104: variable '${key}' not found`);\n    }\n\n    const varValue = vars.get(key);\n    return varValue === scope.substring(scopeLeft, scopeSlider);\n  }\n\n  if (ruleSlider - ruleLeft === 1 && rule[ruleLeft] === wildcard) {\n    return true;\n  }\n\n  if (rule.substring(ruleLeft, ruleSlider).indexOf(arraySeperator) >= 0) {\n    for (; ruleLeft < ruleSlider;) {\n      const arrayRight = endOfArrayElement(rule, ruleLeft);\n\n      if (rule[ruleLeft] === varPrefix) {\n        throw new Error(`scopie-101: variable '${rule.substring(ruleLeft + 1, arrayRight)}' found in array block`);\n      }\n\n      if (rule[ruleLeft] === wildcard) {\n        if (arrayRight - ruleLeft > 1 && rule[ruleLeft + 1] === wildcard) {\n          throw new Error('scopie-103: super wildcard found in array block');\n        }\n\n        throw new Error('scopie-102: wildcard found in array block');\n      }\n\n      if (rule.substring(ruleLeft, arrayRight) === scope.substring(scopeLeft, scopeSlider)) {\n        return true;\n      }\n\n      ruleLeft = arrayRight + 1;\n    }\n\n    return false;\n  }\n\n  return rule.substring(ruleLeft, ruleSlider) === scope.substring(scopeLeft, scopeSlider);\n}\n\n/** Determines if an rule matches a scope\n * @param {string} scope\n * @param {string} rule\n * @param {Map<string,string>} vars - Variables for translations\n * @returns {boolean} Whether or not the scope matches the rule\n */\nfunction compareScopeToRule(scope, rule, vars) {\n  // Skip the allow and deny prefix for rules\n  let ruleLeft = endOfBlock('rule', rule, 0) + 1;\n  let scopeLeft = 0;\n  let ruleSlider = 0;\n  let scopeSlider = 0;\n\n  for (; ruleLeft < rule.length || scopeLeft < scope.length;) {\n    // In case one is longer then the other\n    if ((ruleLeft < rule.length) !== (scopeLeft < scope.length)) {\n      return false;\n    }\n\n    scopeSlider = endOfBlock('scope', scope, scopeLeft);\n    ruleSlider = endOfBlock('rule', rule, ruleLeft);\n\n    // Super wildcards are checked here as it skips the who rest of the checks.\n    if (\n      ruleSlider - ruleLeft === 2\n      && rule[ruleLeft] === wildcard\n      && rule[ruleLeft + 1] === wildcard\n    ) {\n      if (rule.length > ruleSlider) {\n        throw new Error('scopie-105: super wildcard not in the last block');\n      }\n\n      return true;\n    }\n    if (!compareBlock(\n      rule,\n      ruleLeft,\n      ruleSlider,\n      scope,\n      scopeLeft,\n      scopeSlider,\n      vars,\n    )) {\n      return false;\n    }\n\n    scopeLeft = scopeSlider + 1;\n    ruleLeft = ruleSlider + 1;\n  }\n\n  return true;\n}\n\n/**\n * Validate if our user is allowed to perform the action based on their rules and the required scopes.\n * @param {string[]} scopes - Required scopes\n * @param {string[]} rules - What rules our user has\n * @param {object} vars - User variables that are replacable in scopes\n */\nexport function isAllowed(scopes, rules, vars) {\n  if (rules.length === 0) {\n    return false;\n  }\n\n  if (scopes.length === 0) {\n    throw new Error('scopie-106 in scope: scopes was empty');\n  }\n\n  let varMap;\n  if (vars) {\n    varMap = new Map(Object.entries(vars));\n  }\n\n  let hasBeenAllowed = false;\n\n  for (let ruleIndex = 0; ruleIndex < rules.length; ruleIndex += 1) {\n    const rule = rules[ruleIndex];\n    if (rule.length === 0) {\n      throw new Error('scopie-106 in rule: rule was empty');\n    }\n\n    const isAllowBlock = rule[0] === 'a';\n    if (isAllowBlock && hasBeenAllowed) {\n      continue;\n    }\n\n    for (let scopeIndex = 0; scopeIndex < scopes.length; scopeIndex += 1) {\n      const scope = scopes[scopeIndex];\n      if (scope.length === 0) {\n        throw new Error('scopie-106 in scope: scope was empty');\n      }\n\n      const match = compareScopeToRule(scope, rule, varMap);\n      if (match && isAllowBlock) {\n        hasBeenAllowed = true;\n      } else if (match && !isAllowBlock) {\n        return false;\n      }\n    }\n  }\n\n  return hasBeenAllowed;\n}\n\n/**\n * Determines whether or not the scopes or rules are valid according to scopie rules.\n * @param {string[]} scopeOrRules - Scope or rules to check\n * @returns {Error|undefined} If the scope is invalid, the validation error is returned,\n * otherwise undefined is returned.\n */\nexport function validateScopes(scopeOrRules) {\n  if (scopeOrRules.length === 0) {\n    return new Error('scopie-106: scopes are empty');\n  }\n\n  const isRules = scopeOrRules[0].startsWith(allowPermission) ||\n    scopeOrRules[0].startsWith(denyPermission)\n\n  for (let scope of scopeOrRules) {\n    if (scope.length === 0) {\n      return new Error('scopie-106: scope or rule was empty');\n    }\n\n    const isScopeRules = scope.startsWith(allowPermission) ||\n      scope.startsWith(denyPermission)\n    if (isRules != isScopeRules) {\n      return new Error('scopie-107: inconsistent array of scopes and rules');\n    }\n\n    let inArray = false;\n\n    for (let i = 0; i < scope.length; i += 1) {\n      if (scope[i] === blockSeperator) {\n        inArray = false;\n        continue;\n      }\n\n      if (scope[i] === arraySeperator) {\n        inArray = true;\n        continue;\n      }\n\n      if (inArray) {\n        if (scope[i] === wildcard && i < scope.length - 1 && scope[i + 1] === wildcard) {\n          return new Error('scopie-103: super wildcard found in array block');\n        }\n\n        if (scope[i] === wildcard) {\n          return new Error('scopie-102: wildcard found in array block');\n        }\n\n        if (scope[i] === varPrefix) {\n          const end = endOfArrayElement(scope, i);\n          return new Error(`scopie-101: variable '${scope.substring(i + 1, end)}' found in array block`);\n        }\n      }\n\n      if (!isValidCharacter(scope[i])) {\n        return new Error(`scopie-100: invalid character '${scope[i]}'`);\n      }\n\n      if (scope[i] === wildcard && i < scope.length - 1 && scope[i + 1] === wildcard\n        && i < scope.length - 2) {\n        return new Error('scopie-105: super wildcard not in the last block');\n      }\n    }\n  }\n\n  return undefined;\n}\n"],
  "mappings": "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",
  "names": ["isValidCharacter", "char", "endOfArrayElement", "value", "start", "i", "endOfBlock", "category", "compareBlock", "rule", "ruleLeft", "ruleSlider", "scope", "scopeLeft", "scopeSlider", "vars", "key", "arrayRight", "compareScopeToRule", "scopes", "rules", "varMap", "hasBeenAllowed", "ruleIndex", "isAllowBlock", "scopeIndex", "match", "scopeOrRules", "isRules", "isScopeRules", "inArray", "end"]
}
